#include "Application.h"


/*
 * Copyright (c) 2018-2020 The Forge Interactive Inc.
 *
 * This file is part of The-Forge
 * (see https://github.com/ConfettiFX/The-Forge).
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
*/

#include "../The-Forge/Common_3/ThirdParty/OpenSource/EASTL/vector.h"
#include "../The-Forge/Common_3/ThirdParty/OpenSource/EASTL/string.h"
#include "../The-Forge/Common_3/ThirdParty/OpenSource/EASTL/unordered_map.h"

//Interfaces
#include "../The-Forge/Common_3/OS/Interfaces/ICameraController.h"
#include "../The-Forge/Common_3/OS/Interfaces/ILog.h"
#include "../The-Forge/Common_3/OS/Interfaces/IFileSystem.h"
#include "../The-Forge/Common_3/OS/Interfaces/ITime.h"
#include "../The-Forge/Common_3/OS/Interfaces/IInput.h"
#include "../The-Forge/Middleware_3/UI/AppUI.h"
#include "../The-Forge/Common_3/Renderer/IRenderer.h"
#include "../The-Forge/Common_3/Renderer/IResourceLoader.h"
#include "../The-Forge/Common_3/OS/Interfaces/IProfiler.h"

//Math
#include "../The-Forge/Common_3/OS/Math/MathTypes.h"
#include "../The-Forge/Common_3/OS/Interfaces/IMemory.h"    // Must be last include in cpp file


namespace {
	struct UniformBlock
	{
		mat4		projView;
		mat4		toWorld;
		//mat44		shadowLightViewProj;
		float4      camPos;
		float4      lightColor[4];
		float4      lightDirection[3];
	};
};

// Rendering variables

uint32_t Application::gImageCount = IMAGE_COUNT;
uint32_t Application::gFrameIndex = 0;

Renderer* pRenderer = NULL;

Queue* pGraphicsQueue = NULL;

CmdPool* pCmdPool = NULL;
Cmd** ppCmds = NULL;

SwapChain* pSwapChain = NULL;

RenderTarget* pForwardRT = NULL;
RenderTarget* pDepthBuffer = NULL;

Fence* pRenderCompleteFences[IMAGE_COUNT] = { NULL };

Semaphore* pImageAcquiredSemaphore = NULL;
Semaphore* pRenderCompleteSemaphores[IMAGE_COUNT] = { NULL };

Shader* pMeshShader = NULL;

Pipeline* pMeshPipeline = NULL;

RootSignature* pRootSignatureShaded = NULL;

DescriptorSet* pDescriptorSetsShaded[DESCRIPTOR_UPDATE_FREQ_COUNT];


VirtualJoystickUI gVirtualJoystick;

Buffer* pUniformBuffer[IMAGE_COUNT] = { NULL };

Sampler* pDefaultSampler = NULL;

UniformBlock gUniformBlock;

ICameraController* pCameraController = NULL;


// UI variables
UIApp gAppUI;
TextDrawDesc gFrameTimeDraw = TextDrawDesc(0, 0xff00ffff, 18);
ProfileToken gGpuProfileToken = PROFILE_INVALID_TOKEN;


// Other variables

const uint gBackroundColor = { 0xb2b2b2ff };

mat4 Application::projMat;
mat4 Application::viewMat;

GLTFObject* player;




bool Application::InitializeShaderPrograms() {

	// Initialize shaders
	ShaderLoadDesc meshShader = {};
	meshShader.mStages[0] = { "shader.vert", NULL, 0, RD_SHADER_SOURCES };
	meshShader.mStages[1] = { "shader.frag", NULL, 0, RD_SHADER_SOURCES };

	addShader(pRenderer, &meshShader, &pMeshShader);

	// Initialize samplers
	SamplerDesc defaultSamplerDesc = {
			FILTER_LINEAR, FILTER_LINEAR, MIPMAP_MODE_LINEAR,
			ADDRESS_MODE_REPEAT, ADDRESS_MODE_REPEAT, ADDRESS_MODE_REPEAT
	};
	addSampler(pRenderer, &defaultSamplerDesc, &pDefaultSampler);

	// Initialize Root Signatures
	const char* pStaticSamplerNames[] = { "defaultSampler" };
	Sampler* pStaticSamplers[] = { pDefaultSampler };
	Shader* shaders[] = { pMeshShader };
	RootSignatureDesc rootDesc = {};
	rootDesc.mStaticSamplerCount = 1;
	rootDesc.ppStaticSamplerNames = pStaticSamplerNames;
	rootDesc.ppStaticSamplers = pStaticSamplers;
	rootDesc.mShaderCount = 1;
	rootDesc.ppShaders = shaders;
	addRootSignature(pRenderer, &rootDesc, &pRootSignatureShaded);

	// Initialize Descriptor Sets
	DescriptorSetDesc setDesc = { pRootSignatureShaded, DESCRIPTOR_UPDATE_FREQ_NONE, 1 };
	addDescriptorSet(pRenderer, &setDesc, &pDescriptorSetsShaded[DESCRIPTOR_UPDATE_FREQ_NONE]);
	setDesc = { pRootSignatureShaded, DESCRIPTOR_UPDATE_FREQ_PER_FRAME, gImageCount };
	addDescriptorSet(pRenderer, &setDesc, &pDescriptorSetsShaded[DESCRIPTOR_UPDATE_FREQ_PER_FRAME]);

	return true;
}

bool Application::CleanShaderResources() {
	removeDescriptorSet(pRenderer, pDescriptorSetsShaded[DESCRIPTOR_UPDATE_FREQ_NONE]);
	removeDescriptorSet(pRenderer, pDescriptorSetsShaded[DESCRIPTOR_UPDATE_FREQ_PER_FRAME]);

	removeShader(pRenderer, pMeshShader);
	removeRootSignature(pRenderer, pRootSignatureShaded);

	return true;
}


bool Application::InitializeObjects() {

	player = conf_new(GLTFObject);
	PathHandle fullModelPath = fsCopyPathInResourceDirectory(RD_MESHES, "SpinningBox.gltf");
	if (!GLTFObject::LoadModel(player, pRenderer, pDefaultSampler, fullModelPath)) return false;

	DescriptorData params[1] = {};
	if (player->pNodeTransformsBuffer)
	{
		params[0].pName = "modelToSceneMatrices";
		params[0].ppBuffers = &player->pNodeTransformsBuffer;
	}
	updateDescriptorSet(pRenderer, 0, pDescriptorSetsShaded[DESCRIPTOR_UPDATE_FREQ_NONE], player->pNodeTransformsBuffer ? 1 : 0, params);

	for (uint32_t i = 0; i < gImageCount; ++i)
	{
		params[0].pName = "cbPerPass";
		params[0].ppBuffers = &pUniformBuffer[i];
		updateDescriptorSet(pRenderer, i, pDescriptorSetsShaded[DESCRIPTOR_UPDATE_FREQ_PER_FRAME], 1, params);
	}

	player->createMaterialResources(pRootSignatureShaded, NULL);

	return true;
}

bool Application::CleanObjectResources() {
	player->removeResources();

	return true;
}

void Application::setRenderTarget(Cmd* cmd, uint32_t count, RenderTarget** pDestinationRenderTargets, RenderTarget* pDepthStencilTarget, LoadActionsDesc* loadActions)
{
	if (count == 0 && pDestinationRenderTargets == NULL && pDepthStencilTarget == NULL)
		cmdBindRenderTargets(cmd, 0, NULL, NULL, NULL, NULL, NULL, -1, -1);
	else
	{
		cmdBindRenderTargets(cmd, count, pDestinationRenderTargets, pDepthStencilTarget, loadActions, NULL, NULL, -1, -1);
		// sets the rectangles to match with first attachment, I know that it's not very portable.
		RenderTarget* pSizeTarget = pDepthStencilTarget ? pDepthStencilTarget : pDestinationRenderTargets[0];
		cmdSetViewport(cmd, 0.0f, 0.0f, (float)pSizeTarget->mWidth, (float)pSizeTarget->mHeight, 0.0f, 1.0f);
		cmdSetScissor(cmd, 0, 0, pSizeTarget->mWidth, pSizeTarget->mHeight);
	}
}

bool Application::Init()
{
	// FILE PATHS
	PathHandle programDirectory = fsCopyProgramDirectoryPath();
	if (!fsPlatformUsesBundledResources())
	{
		PathHandle resourceDirRoot = fsAppendPathComponent(programDirectory, "../../../../../../src");
		fsSetResourceDirectoryRootPath(resourceDirRoot);

		fsSetRelativePathForResourceDirectory(RD_TEXTURES, "../Assets/Textures");
		fsSetRelativePathForResourceDirectory(RD_MESHES, "../Assets/Meshes");
		fsSetRelativePathForResourceDirectory(RD_BUILTIN_FONTS, "../Assets/Fonts");
		fsSetRelativePathForResourceDirectory(RD_ANIMATIONS, "../Assets/Animation");
		fsSetRelativePathForResourceDirectory(RD_MIDDLEWARE_TEXT, "../The-Forge/Middleware_3/Text");
		fsSetRelativePathForResourceDirectory(RD_MIDDLEWARE_UI, "../The-Forge/Middleware_3/UI");
	}

	// window and renderer setup
	RendererDesc settings = { 0 };
	initRenderer(GetName(), &settings, &pRenderer);
	//check for init success
	if (!pRenderer)
		return false;

	QueueDesc queueDesc = {};
	queueDesc.mType = QUEUE_TYPE_GRAPHICS;
	queueDesc.mFlag = QUEUE_FLAG_INIT_MICROPROFILE;
	addQueue(pRenderer, &queueDesc, &pGraphicsQueue);
	CmdPoolDesc cmdPoolDesc = {};
	cmdPoolDesc.pQueue = pGraphicsQueue;
	addCmdPool(pRenderer, &cmdPoolDesc, &pCmdPool);
	CmdDesc cmdDesc = {};
	cmdDesc.pPool = pCmdPool;
	addCmd_n(pRenderer, &cmdDesc, Application::gImageCount, &ppCmds);

	for (uint32_t i = 0; i < Application::gImageCount; ++i)
	{
		addFence(pRenderer, &pRenderCompleteFences[i]);
		addSemaphore(pRenderer, &pRenderCompleteSemaphores[i]);
	}
	addSemaphore(pRenderer, &pImageAcquiredSemaphore);

	initResourceLoaderInterface(pRenderer);

	// Initialize UI
	if (!gAppUI.Init(pRenderer))
		return false;

	gAppUI.LoadFont("TitilliumText/TitilliumText-Bold.otf", RD_BUILTIN_FONTS);

	waitForAllResourceLoads();

	// Prepare descriptor sets
	BufferLoadDesc ubDesc = {};
	ubDesc.mDesc.mDescriptors = DESCRIPTOR_TYPE_UNIFORM_BUFFER;
	ubDesc.mDesc.mMemoryUsage = RESOURCE_MEMORY_USAGE_CPU_TO_GPU;
	ubDesc.mDesc.mSize = sizeof(UniformBlock);
	ubDesc.mDesc.mFlags = BUFFER_CREATION_FLAG_PERSISTENT_MAP_BIT;
	ubDesc.pData = NULL;
	for (uint32_t i = 0; i < gImageCount; ++i)
	{
		ubDesc.ppBuffer = &pUniformBuffer[i];
		addResource(&ubDesc, NULL, LOAD_PRIORITY_NORMAL);
	}


	// Initialize Camera
	CameraMotionParameters cmp{ 160.0f, 600.0f, 200.0f };
	vec3                   camPos{ 48.0f, 48.0f, 20.0f };
	vec3                   lookAt{ vec3(0) };

	pCameraController = createFpsCameraController(camPos, lookAt);

	pCameraController->setMotionParameters(cmp);

	if (!initInputSystem(pWindow))
		return false;

	// Initialize microprofiler and it's UI.
	initProfiler();

	// Gpu profiler can only be added after initProfile.
	gGpuProfileToken = addGpuProfiler(pRenderer, pGraphicsQueue, "GpuProfiler");

	// App Actions
	if (!gVirtualJoystick.Init(pRenderer, "circlepad", RD_TEXTURES))
	{
		LOGF(LogLevel::eERROR, "Could not initialize Virtual Joystick.");
		return false;
	}

	InputActionDesc actionDesc = { InputBindings::BUTTON_DUMP, [](InputActionContext* ctx) { dumpProfileData(((IApp*)ctx->pUserData)->GetName()); return true; }, this };
	addInputAction(&actionDesc);
	actionDesc = { InputBindings::BUTTON_FULLSCREEN, [](InputActionContext* ctx) { toggleFullscreen(((IApp*)ctx->pUserData)->pWindow); return true; }, this };
	addInputAction(&actionDesc);
	actionDesc = { InputBindings::BUTTON_EXIT, [](InputActionContext* ctx) { requestShutdown(); return true; } };
	addInputAction(&actionDesc);
	actionDesc =
	{
		InputBindings::BUTTON_ANY, [](InputActionContext* ctx)
		{
			bool capture = gAppUI.OnButton(ctx->mBinding, ctx->mBool, ctx->pPosition);
			setEnableCaptureInput(capture && INPUT_ACTION_PHASE_CANCELED != ctx->mPhase);
			return true;
		}, this
	};
	addInputAction(&actionDesc);
	typedef bool (*CameraInputHandler)(InputActionContext* ctx, uint32_t index);
	static CameraInputHandler onCameraInput = [](InputActionContext* ctx, uint32_t index)
	{
		if (!gAppUI.IsFocused() && *ctx->pCaptured)
		{
			gVirtualJoystick.OnMove(index, ctx->mPhase != INPUT_ACTION_PHASE_CANCELED, ctx->pPosition);
			index ? pCameraController->onRotate(ctx->mFloat2) : pCameraController->onMove(ctx->mFloat2);
		}
		return true;
	};
	actionDesc = { InputBindings::FLOAT_RIGHTSTICK, [](InputActionContext* ctx) { return onCameraInput(ctx, 1); }, NULL, 20.0f, 200.0f, 0.5f };
	addInputAction(&actionDesc);
	actionDesc = { InputBindings::FLOAT_LEFTSTICK, [](InputActionContext* ctx) { return onCameraInput(ctx, 0); }, NULL, 20.0f, 200.0f, 1.0f };
	addInputAction(&actionDesc);
	actionDesc = { InputBindings::BUTTON_NORTH, [](InputActionContext* ctx) { pCameraController->resetView(); return true; } };
	addInputAction(&actionDesc);

	return true;
}

void Application::Exit()
{
	waitQueueIdle(pGraphicsQueue);

	exitInputSystem();

	exitProfiler();

	destroyCameraController(pCameraController);

	gVirtualJoystick.Exit();

	gAppUI.Exit();

	for (uint32_t i = 0; i < gImageCount; ++i)
	{
		removeResource(pUniformBuffer[i]);
	}

	removeSampler(pRenderer, pDefaultSampler);

	for (uint32_t i = 0; i < Application::gImageCount; ++i)
	{
		removeFence(pRenderer, pRenderCompleteFences[i]);
		removeSemaphore(pRenderer, pRenderCompleteSemaphores[i]);
	}
	removeSemaphore(pRenderer, pImageAcquiredSemaphore);

	removeCmd_n(pRenderer, Application::gImageCount, ppCmds);
	removeCmdPool(pRenderer, pCmdPool);

	removeSampler(pRenderer, pDefaultSampler);

	conf_delete(player);

	exitResourceLoaderInterface(pRenderer);
	removeQueue(pRenderer, pGraphicsQueue);
	removeRenderer(pRenderer);
}

void Application::LoadPipelines()
{
	PipelineDesc desc = {};

	/************************************************************************/
	// Setup the resources needed for shadow map
	/************************************************************************/
	RasterizerStateDesc rasterizerStateDesc = {};
	rasterizerStateDesc.mCullMode = CULL_MODE_BACK;

	DepthStateDesc depthStateDesc = {};
	depthStateDesc.mDepthTest = true;
	depthStateDesc.mDepthWrite = true;
	depthStateDesc.mDepthFunc = CMP_GEQUAL;

	BlendStateDesc blendStateAlphaDesc = {};
	blendStateAlphaDesc.mSrcFactors[0] = BC_SRC_ALPHA;
	blendStateAlphaDesc.mDstFactors[0] = BC_ONE_MINUS_SRC_ALPHA;
	blendStateAlphaDesc.mBlendModes[0] = BM_ADD;
	blendStateAlphaDesc.mSrcAlphaFactors[0] = BC_ONE;
	blendStateAlphaDesc.mDstAlphaFactors[0] = BC_ZERO;
	blendStateAlphaDesc.mBlendAlphaModes[0] = BM_ADD;
	blendStateAlphaDesc.mMasks[0] = ALL;
	blendStateAlphaDesc.mRenderTargetMask = BLEND_STATE_TARGET_0;
	blendStateAlphaDesc.mIndependentBlend = false;

	{
		desc = {};
		desc.mType = PIPELINE_TYPE_GRAPHICS;
		GraphicsPipelineDesc& pipelineSettings = desc.mGraphicsDesc;
		pipelineSettings.mPrimitiveTopo = PRIMITIVE_TOPO_TRI_LIST;
		pipelineSettings.mRenderTargetCount = 1;
		pipelineSettings.pDepthState = &depthStateDesc;
		pipelineSettings.mDepthStencilFormat = pDepthBuffer->mFormat;
		pipelineSettings.pBlendState = &blendStateAlphaDesc;
		pipelineSettings.pColorFormats = &pForwardRT->mFormat;
		pipelineSettings.mSampleCount = pForwardRT->mSampleCount;
		pipelineSettings.mSampleQuality = pForwardRT->mSampleQuality;
		pipelineSettings.pRootSignature = pRootSignatureShaded;
		pipelineSettings.pVertexLayout = &GLTFObject::getVertexLayout();
		pipelineSettings.pRasterizerState = &rasterizerStateDesc;
		pipelineSettings.pShaderProgram = pMeshShader;
		addPipeline(pRenderer, &desc, &pMeshPipeline);
	}
}

bool Application::Load()
{
	if (!addSwapChain())
		return false;

	if (!addRenderTargets())
		return false;

	if (!addDepthBuffer())
		return false;

	if (!gAppUI.Load(pSwapChain->ppRenderTargets))
		return false;

	if (!gVirtualJoystick.Load(pSwapChain->ppRenderTargets[0]))
		return false;

	loadProfilerUI(&gAppUI, mSettings.mWidth, mSettings.mHeight);

	// Initialize shaders
	if (!InitializeShaderPrograms()) return false;

	// Initialize objects
	if (!InitializeObjects()) return false;

	LoadPipelines();

	return true;
}

void Application::Unload()
{
	waitQueueIdle(pGraphicsQueue);

	unloadProfilerUI();
	gAppUI.Unload();

	gVirtualJoystick.Unload();

	removePipeline(pRenderer, pMeshPipeline);

	removeSwapChain(pRenderer, pSwapChain);
	removeRenderTarget(pRenderer, pForwardRT);
	removeRenderTarget(pRenderer, pDepthBuffer);
}

void Application::Update(float deltaTime)
{
	updateInputSystem(mSettings.mWidth, mSettings.mHeight);

	pCameraController->update(deltaTime);
	/************************************************************************/
	// Scene Update
	/************************************************************************/
	static float currentTime = 0.0f;
	currentTime += deltaTime * 1000.0f;

	// update camera with time
	viewMat = pCameraController->getViewMatrix();

	const float aspectInverse = (float)mSettings.mHeight / (float)mSettings.mWidth;
	const float horizontal_fov = PI / 2.0f;
	projMat = mat4::perspective(horizontal_fov, aspectInverse, 1000.0f, 0.1f);

	/************************************************************************/
	// Update GUI
	/************************************************************************/
	gAppUI.Update(deltaTime);
}

void Application::Draw()
{
	acquireNextImage(pRenderer, pSwapChain, pImageAcquiredSemaphore, NULL, &gFrameIndex);

	RenderTarget* pRenderTarget = pSwapChain->ppRenderTargets[gFrameIndex];
	Semaphore* pRenderCompleteSemaphore = pRenderCompleteSemaphores[gFrameIndex];
	Fence* pRenderCompleteFence = pRenderCompleteFences[gFrameIndex];

	// Stall if CPU is running "Swap Chain Buffer Count" frames ahead of GPU
	FenceStatus fenceStatus;
	getFenceStatus(pRenderer, pRenderCompleteFence, &fenceStatus);
	if (fenceStatus == FENCE_STATUS_INCOMPLETE)
		waitForFences(pRenderer, 1, &pRenderCompleteFence);

	Cmd* cmd = ppCmds[gFrameIndex];
	beginCmd(cmd);

	cmdBeginGpuFrameProfile(cmd, gGpuProfileToken);

	RenderTargetBarrier barriers[] = {
		{ pRenderTarget, RESOURCE_STATE_RENDER_TARGET },
		{ pDepthBuffer, RESOURCE_STATE_DEPTH_WRITE },
	};
	cmdResourceBarrier(cmd, 0, NULL, 0, NULL, 2, barriers);


	// Draw scene
	cmdBeginGpuTimestampQuery(cmd, gGpuProfileToken, "Draw Scene");

	cmdSetViewport(cmd, 0.0f, 0.0f, (float)pRenderTarget->mWidth, (float)pRenderTarget->mHeight, 0.0f, 1.0f);
	cmdSetScissor(cmd, 0, 0, pRenderTarget->mWidth, pRenderTarget->mHeight);
	
	vec4 bgColor = vec4(float((gBackroundColor >> 24) & 0xff),
		float((gBackroundColor >> 16) & 0xff),
		float((gBackroundColor >> 8) & 0xff),
		float((gBackroundColor >> 0) & 0xff)) / 255.0f;
	LoadActionsDesc loadActions = {};
	loadActions.mLoadActionsColor[0] = LOAD_ACTION_CLEAR;
	loadActions.mClearColorValues[0].r = bgColor.getX();
	loadActions.mClearColorValues[0].g = bgColor.getY();
	loadActions.mClearColorValues[0].b = bgColor.getZ();
	loadActions.mClearColorValues[0].a = bgColor.getW();
	loadActions.mLoadActionDepth = LOAD_ACTION_CLEAR;
	loadActions.mClearDepth.depth = 0.0f;
	loadActions.mClearDepth.stencil = 0;
	cmdBindRenderTargets(cmd, 1, &pRenderTarget, pDepthBuffer, &loadActions, NULL, NULL, -1, -1);

	// Draw object
	cmdBindPipeline(cmd, pMeshPipeline);
	cmdBindDescriptorSet(cmd, 0, pDescriptorSetsShaded[DESCRIPTOR_UPDATE_FREQ_NONE]);
	cmdBindDescriptorSet(cmd, gFrameIndex, pDescriptorSetsShaded[DESCRIPTOR_UPDATE_FREQ_PER_FRAME]);
	player->draw(cmd, pRootSignatureShaded, true);

	cmdBindRenderTargets(cmd, 0, NULL, 0, NULL, NULL, NULL, -1, -1);
	cmdEndGpuTimestampQuery(cmd, gGpuProfileToken);



	cmdBeginGpuTimestampQuery(cmd, gGpuProfileToken, "Draw UI");

	gVirtualJoystick.Draw(cmd, { 1.0f, 1.0f, 1.0f, 1.0f });

	cmdDrawCpuProfile(cmd, float2(8, 15), &gFrameTimeDraw);
#if !defined(__ANDROID__)
	cmdDrawGpuProfile(cmd, float2(8, 40), gGpuProfileToken, &gFrameTimeDraw);
#endif

	cmdDrawProfilerUI();

	gAppUI.Draw(cmd);
	cmdBindRenderTargets(cmd, 0, NULL, NULL, NULL, NULL, NULL, -1, -1);
	cmdEndGpuTimestampQuery(cmd, gGpuProfileToken);

	barriers[0] = { pRenderTarget, RESOURCE_STATE_PRESENT };
	cmdResourceBarrier(cmd, 0, NULL, 0, NULL, 1, barriers);

	cmdEndGpuFrameProfile(cmd, gGpuProfileToken);
	endCmd(cmd);

	QueueSubmitDesc submitDesc = {};
	submitDesc.mCmdCount = 1;
	submitDesc.mSignalSemaphoreCount = 1;
	submitDesc.mWaitSemaphoreCount = 1;
	submitDesc.ppCmds = &cmd;
	submitDesc.ppSignalSemaphores = &pRenderCompleteSemaphore;
	submitDesc.ppWaitSemaphores = &pImageAcquiredSemaphore;
	submitDesc.pSignalFence = pRenderCompleteFence;
	queueSubmit(pGraphicsQueue, &submitDesc);
	QueuePresentDesc presentDesc = {};
	presentDesc.mIndex = gFrameIndex;
	presentDesc.mWaitSemaphoreCount = 1;
	presentDesc.pSwapChain = pSwapChain;
	presentDesc.ppWaitSemaphores = &pRenderCompleteSemaphore;
	presentDesc.mSubmitDone = true;
	queuePresent(pGraphicsQueue, &presentDesc);
	flipProfiler();
}

bool Application::addSwapChain()
{
	SwapChainDesc swapChainDesc = {};
	swapChainDesc.mWindowHandle = pWindow->handle;
	swapChainDesc.mPresentQueueCount = 1;
	swapChainDesc.ppPresentQueues = &pGraphicsQueue;
	swapChainDesc.mWidth = mSettings.mWidth;
	swapChainDesc.mHeight = mSettings.mHeight;
	swapChainDesc.mImageCount = Application::gImageCount;
	swapChainDesc.mColorFormat = getRecommendedSwapchainFormat(true);
	swapChainDesc.mEnableVsync = false;
	::addSwapChain(pRenderer, &swapChainDesc, &pSwapChain);

	return pSwapChain != NULL;
}

bool Application::addRenderTargets()
{
	RenderTargetDesc RT = {};
	RT.mArraySize = 1;
	RT.mDepth = 1;
	RT.mFormat = TinyImageFormat_R8G8B8A8_UNORM;

	vec4 bgColor = vec4(float((gBackroundColor >> 24) & 0xff),
		float((gBackroundColor >> 16) & 0xff),
		float((gBackroundColor >> 8) & 0xff),
		float((gBackroundColor >> 0) & 0xff)) / 255.0f;

	RT.mClearValue.r = bgColor.getX();
	RT.mClearValue.g = bgColor.getY();
	RT.mClearValue.b = bgColor.getZ();
	RT.mClearValue.a = bgColor.getW();

	RT.mWidth = mSettings.mWidth;
	RT.mHeight = mSettings.mHeight;

	RT.mSampleCount = SAMPLE_COUNT_1;
	RT.mSampleQuality = 0;
	RT.pDebugName = L"Render Target";
	addRenderTarget(pRenderer, &RT, &pForwardRT);

	return pForwardRT != NULL;
}

bool Application::addDepthBuffer()
{
	// Add depth buffer
	RenderTargetDesc depthRT = {};
	depthRT.mArraySize = 1;
	depthRT.mClearValue.depth = 0.0f;
	depthRT.mClearValue.stencil = 0;
	depthRT.mDepth = 1;
	depthRT.mFormat = TinyImageFormat_D32_SFLOAT;
	depthRT.mHeight = mSettings.mHeight;
	depthRT.mSampleCount = SAMPLE_COUNT_1;
	depthRT.mSampleQuality = 0;
	depthRT.mWidth = mSettings.mWidth;
	depthRT.mFlags = TEXTURE_CREATION_FLAG_ON_TILE;
	addRenderTarget(pRenderer, &depthRT, &pDepthBuffer);

	return pDepthBuffer != NULL;
}


DEFINE_APPLICATION_MAIN(Application)